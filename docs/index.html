<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>Duel Arena</title>
<style>
  body {
    margin: 0;
    background: #111;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    color: white;
    font-family: Arial, sans-serif;
  }
  canvas {
    background: radial-gradient(circle at center, #222, #000);
    border: 2px solid #555;
  }
</style>
</head>
<body>

<canvas id="game" width="800" height="600"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const keys = {};
document.addEventListener("keydown", e => keys[e.code] = true);
document.addEventListener("keyup", e => keys[e.code] = false);

let gameOver = false;
let winnerText = "";

/* ================= PLAYER ================= */
class Player {
  constructor(x, y, color, controls) {
    this.startX = x;
    this.startY = y;
    this.x = x;
    this.y = y;
    this.size = 18;
    this.color = color;

    this.vx = 0;
    this.vy = 0;
    this.acceleration = 0.25;
    this.maxSpeed = 4;
    this.friction = 0.92;

    this.hp = 5;
    this.maxHp = 5;
    this.cooldown = 0;
    this.shootDelay = 35;

    this.angle = 0;
    this.targetAngle = 0;
    this.turnSpeed = 0.08;

    this.thrusting = false;
    this.controls = controls;
  }

  move() {
    let ax = 0, ay = 0;
    this.thrusting = false;

    if (keys[this.controls.up]) ay -= 1;
    if (keys[this.controls.down]) ay += 1;
    if (keys[this.controls.left]) ax -= 1;
    if (keys[this.controls.right]) ax += 1;

    if (ax || ay) {
      const len = Math.hypot(ax, ay);
      ax /= len;
      ay /= len;

      this.targetAngle = Math.atan2(ay, ax);
      this.vx += ax * this.acceleration;
      this.vy += ay * this.acceleration;
      this.thrusting = true;
    }

    const speed = Math.hypot(this.vx, this.vy);
    if (speed > this.maxSpeed) {
      this.vx = this.vx / speed * this.maxSpeed;
      this.vy = this.vy / speed * this.maxSpeed;
    }

    const prevX = this.x;
    const prevY = this.y;

    this.x += this.vx;
    this.y += this.vy;

    // –∑–æ–≤–Ω—ñ—à–Ω—ñ –º–µ–∂—ñ
    this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
    this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));

    // –∫–æ–ª—ñ–∑—ñ—è –∑—ñ —Å—Ç—ñ–Ω–∞–º–∏
    walls.forEach(w => {
      if (this.collidesWithWall(w)) {
        this.x = prevX;
        this.y = prevY;
        this.vx = 0;
        this.vy = 0;
      }
    });

    this.vx *= this.friction;
    this.vy *= this.friction;
  }

  collidesWithWall(wall) {
    return !(this.x + this.size < wall.x ||
             this.x - this.size > wall.x + wall.w ||
             this.y + this.size < wall.y ||
             this.y - this.size > wall.y + wall.h);
  }

  updateRotation() {
    let diff = this.targetAngle - this.angle;
    diff = Math.atan2(Math.sin(diff), Math.cos(diff));
    this.angle += diff * this.turnSpeed;
  }

  shoot() {
    if (keys[this.controls.shoot] && this.cooldown <= 0) {
      bullets.push(new Bullet(
        this.x + Math.cos(this.angle) * this.size,
        this.y + Math.sin(this.angle) * this.size,
        this.angle,
        this
      ));

      this.vx -= Math.cos(this.angle) * 0.6;
      this.vy -= Math.sin(this.angle) * 0.6;

      this.cooldown = this.shootDelay;
    }
  }

  update() {
    this.move();
    this.updateRotation();
    this.shoot();
    if (this.cooldown > 0) this.cooldown--;
  }

  drawEngineFire() {
    if (!this.thrusting) return;
    const len = this.size + Math.random() * 6;

    ctx.fillStyle = "orange";
    ctx.beginPath();
    ctx.moveTo(-this.size, 0);
    ctx.lineTo(-this.size - len, -5);
    ctx.lineTo(-this.size - len, 5);
    ctx.fill();
  }

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);

    this.drawEngineFire();

    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(this.size, 0);
    ctx.lineTo(-this.size, -this.size / 1.5);
    ctx.lineTo(-this.size / 2, 0);
    ctx.lineTo(-this.size, this.size / 1.5);
    ctx.fill();

    ctx.restore();
  }

  drawHP(x, y) {
    ctx.fillStyle = "white";
    ctx.fillRect(x, y, 100, 15);
    ctx.fillStyle = "lime";
    ctx.fillRect(x, y, 100 * (this.hp / this.maxHp), 15);
    ctx.strokeStyle = "black";
    ctx.strokeRect(x, y, 100, 15);
  }

  reset() {
    this.x = this.startX;
    this.y = this.startY;
    this.vx = 0;
    this.vy = 0;
    this.hp = this.maxHp;
    this.angle = 0;
    this.targetAngle = 0;
  }
}

/* ================= WALL ================= */
class Wall {
  constructor(x, y, w, h, hp) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    this.hp = hp;
    this.initialHp = hp;
  }

  hit() {
    if (this.hp !== Infinity) this.hp--;
  }

  draw() {
    if (this.hp === Infinity) ctx.fillStyle = "#555";
    else if (this.hp > 2) ctx.fillStyle = "#6b3e26";
    else ctx.fillStyle = "#a66a3f";

    ctx.fillRect(this.x, this.y, this.w, this.h);
  }
}

/* ================= BULLET ================= */
class Bullet {
  constructor(x, y, angle, owner) {
    this.x = x;
    this.y = y;
    this.dx = Math.cos(angle);
    this.dy = Math.sin(angle);
    this.speed = 7;
    this.r = 3;
    this.owner = owner;
  }

  update() {
    this.x += this.dx * this.speed;
    this.y += this.dy * this.speed;
  }

  draw() {
    ctx.fillStyle = "yellow";
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
    ctx.fill();
  }
}

/* ================= GAME OBJECTS ================= */
let player1 = new Player(100, 300, "dodgerblue", {up:"KeyW", down:"KeyS", left:"KeyA", right:"KeyD", shoot:"Space"});
let player2 = new Player(700, 300, "crimson", {up:"ArrowUp", down:"ArrowDown", left:"ArrowLeft", right:"ArrowRight", shoot:"Enter"});

let bullets = [];
let walls = [
  new Wall(300, 150, 200, 20, Infinity),
  new Wall(300, 430, 200, 20, Infinity),
  new Wall(200, 280, 60, 60, 2),
  new Wall(540, 280, 60, 60, 4)
];

/* ================= COLLISIONS ================= */
function rectCircleCollide(rect, cx, cy, r) {
  const x = Math.max(rect.x, Math.min(cx, rect.x + rect.w));
  const y = Math.max(rect.y, Math.min(cy, rect.y + rect.h));
  return Math.hypot(cx - x, cy - y) < r;
}

function checkCollisions() {
  bullets.forEach((b, i) => {
    walls.forEach((w, wi) => {
      if (rectCircleCollide(w, b.x, b.y, b.r)) {
        w.hit();
        bullets.splice(i, 1);
        if (w.hp === 0) walls.splice(wi, 1);
      }
    });

    [player1, player2].forEach(p => {
      if (p !== b.owner) {
        if (Math.hypot(b.x - p.x, b.y - p.y) < p.size) {
          p.hp--;
          bullets.splice(i, 1);
          if (p.hp <= 0) {
            gameOver = true;
            winnerText = p === player1 ? "üî¥ Player 2 Wins!" : "üîµ Player 1 Wins!";
          }
        }
      }
    });
  });
}

/* ================= GAME LOOP ================= */
function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // HP –≥—Ä–∞–≤—Ü—ñ–≤ –∑–≤–µ—Ä—Ö—É
  player1.drawHP(50, 20);
  player2.drawHP(canvas.width - 150, 20);

  if (!gameOver) {
    player1.update();
    player2.update();

    bullets.forEach(b => b.update());
    bullets = bullets.filter(b => b.x>0 && b.x<canvas.width && b.y>0 && b.y<canvas.height);

    checkCollisions();

    walls.forEach(w => w.draw());
    player1.draw();
    player2.draw();
    bullets.forEach(b => b.draw());
  } else {
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "white";
    ctx.font = "40px Arial";
    ctx.textAlign = "center";
    ctx.fillText(winnerText, canvas.width/2, canvas.height/2);
    ctx.font = "20px Arial";
    ctx.fillText("–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å R –¥–ª—è –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫—É", canvas.width/2, canvas.height/2+40);

    if (keys["KeyR"]) restartGame();
  }

  requestAnimationFrame(gameLoop);
}

/* ================= RESTART ================= */
function restartGame() {
  bullets = [];
  player1.reset();
  player2.reset();
  walls = [
    new Wall(300, 150, 200, 20, Infinity),
    new Wall(300, 430, 200, 20, Infinity),
    new Wall(200, 280, 60, 60, 2),
    new Wall(540, 280, 60, 60, 4)
  ];
  gameOver = false;
  winnerText = "";
}

gameLoop();
</script>
</body>
</html>
